---
title: "espresso"
author: "Tomoya Mori"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
  toc: true
  toc_depth: 3
vignette: >
  %\VignetteIndexEntry{espresso}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

`espresso` is a package for domain estimation of cells only from gene expression profile 
based on graph-structured stochastic self-organizing map (GraphSOM) and Markov chain Monte Carlo (MCMC) method.   
  
    
# Installation

`espresso` can be installed by the following command.

```{r, eval = FALSE}
# Installation (X.X.X is a version number)
install.packages("espresso_X.X.X.tar.gz", repos = NULL, type = "source")
```

If an error message "ERROR: dependencies 'XXX' are not available for package 'espresso'" is displayed
in the installation step, please try to install required packages, which are listed as follows.

__CRAN packages__

* igraph
* mclust
* progress
* uwot
* rgl
* rFerns
* Boruta
* doParallel
* foreach
* pheatmap
* RColorBrewer
* scatterplot3d
* tagcloud
* plotrix

```{r, eval = FALSE}
# Installation example of CRAN packages
install.packages(c("igraph", "mclust", "progress", "uwot", "rgl", 
                   "rFerns", "Boruta", "doParallel", "foreach", "pheatmap", 
                   "RColorBrewer", "scatterplot3d", "tagcloud", "plotrix"), 
                 dependencies = TRUE)
```

__Bioconductor packages__

* biomaRt
* GO.db

```{r, eval = FALSE}
# Installation example of Bioconductor packages
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(c("biomaRt","GO.db"))
```

__Note__

If you try to install or load `espresso` 
on a machine that does not have X11,
a warning message will be displayed because 
`rgl` package requires X11 to be installed.
In such case, install X11, or ignore the warning 
if you do not need UMAP plots.

# Confirmed version
This vignette was generated by the following versions of R and packages.
```{r}
version
packageVersion("igraph")
packageVersion("mclust")
packageVersion("progress")
packageVersion("uwot")
packageVersion("rgl")
packageVersion("rFerns")
packageVersion("Boruta")
packageVersion("doParallel")
packageVersion("foreach")
packageVersion("pheatmap")
packageVersion("RColorBrewer")
packageVersion("scatterplot3d")
packageVersion("tagcloud")
packageVersion("plotrix")
packageVersion("biomaRt")
packageVersion("GO.db")
```
Note that some versions of R may not be consistent with the `biomaRt` and `dplyr` pacakages. In such case, please install the above versions or updates R and the packages.

# Quick example

`espresso` can be easily executed by a few funcions. 
Here, the most simple code is shown in the following, assuming that a gene expression profile `exprs`, 
a domain topology `topology`, and a domain assignment `asgmt` are already defined.
The details of these inputs are explained in the later section.

```{r message=FALSE, warning=FALSE, include=FALSE}
library(espresso)
set.seed(123)
```

```{r, eval = FALSE}
library(espresso)

# Initialize espresso object
eobj <- initEsp(exprs, topology, asgmt)

# GraphSOM clustering
eobj <- initGraphSOM(eobj)
eobj <- graphSOM(eobj)

# Show prediction scores
eobj@summary
```

If you need more details of the `espresso` functions,
refere the following sections and help manuals 
by `help` function (e.g., `help(espresso)`, `help(graphSOM)` etc.)

# More details

## Data format
`espresso` requires three inputs, i.e., 
expression profile, domain topology, and domain assignment information 
for cell samples.

* __Expression profile__ `exprs`  
The expression profile is given as a numeric matrix whose rows and columns indicate 
cell samples and genes, respectively.

|        |        |        |        |     |
|:-------|-------:|-------:|-------:|----:|
|        | Gene 1 | Gene 2 | Gene 3 | ... |
| Cell 1 | 0.15   | 0.28   | 1.33   | ... |
| Cell 2 | 1.08   | 0.62   | 0.01   | ... |
| Cell 3 | 0.74   | 0.42   | 0.87   | ... |
| ...    | ...    | ...    | ...    | ... |



* __Domain topology__ `topology`  
The domain topology is given as an adjacent matrix whose rows and columns indicate domains.
In this matrix, `1` and `0` mean that corresponding domains are connected 
(i.e., adjacent each other in living a tissue or an organ) and unconnected, respectively.
Note that this matrix must be symmetric and its diagonals must be filled by `0` since self-loops are not assumed in `espresso`.

|          |          |          |          |          |
|:---------|---------:|---------:|---------:|---------:|
|          | Domain 1 | Domain 2 | Domain 3 | Domain 4 |
| Domain 1 |    0     |    1     |    1     |    0     |
| Domain 2 |    1     |    0     |    1     |    1     |
| Domain 3 |    1     |    1     |    0     |    1     |  
| Domain 4 |    0     |    1     |    1     |    0     |

* __Domain assignment__ `asgmt`  
The Domain assignment is given as a `data.frame` with two columns which indicate
cell samples and corresponding domains.

|         |          |
|:--------|:--------:|
| sample  | domain   |
| Cell 1  | Domain 1 |
| Cell 2  | Domain 2 |
| Cell 3  | Domain 1 |
| Cell 4  | Domain 4 |
| ...     | ...      |

`espresso` contains example inputs of raw datasets for the above three inputs:
"exprs_soysa19_e825.txt", "topology_soysa19_e825.txt", and "asgmt_soysa19_e825.txt",
which can be loaded by the following commands.
The expression profile "exprs_soysa19_e825.txt" was created from 
[GSE126128_E775E825_WTKO_10X.csv.gz](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE126128) 
by random selection of 10 single-cells from each domain i.e., 70 cell-samples in total.

```{r}
# Get paths of input files
path_exprs <- system.file("extdata", "exprs_soysa19_e825.txt", package="espresso")
path_topology <- system.file("extdata", "topology_soysa19_e825.txt", package="espresso")
path_asgmt <- system.file("extdata", "asgmt_soysa19_e825.txt", package="espresso")

# Load data
exprs <- t(read.table(path_exprs, header = TRUE, row.names = 1, sep = "\t", 
                      as.is = TRUE, check.names = FALSE))
topology <- as.matrix(read.table(path_topology, header = T, row.names = 1))
asgmt <- read.table(path_asgmt, header = T, as.is = TRUE)

# Show the contents of the objects
exprs[1:5, 1:5]
topology
head(asgmt)
```


## Initialization of ESPRESSO object 

Before executing GraphSOM clustering, `espresso` object should be prepared.
The variables `exprs`, `topology`, and `asgmt` are inputs explained above.
`initEsp` is a function to initialize and return an `espresso` object.

```{r}
eobj <- initEsp(exprs, topology, asgmt)
```

The `espresso` object is defined as `S4` class, and its slots can be accessed by `@` symbol.

```{r}
str(eobj)
```

## Preprocessing (Optional)

`espresso` provides simple preprocessing functions for log-scalling of expression profile and 
filtering out of low expressed and low variable genes. 
If the input expression profile need not be preprocessed, this procedure can be ignored.

### Log-scalling

The input gene expression data can be scaled by log10 as preprocessing.
The base can be changed by specifying `base = "2"` or `base = "e"`.

```{r, eval = FALSE}
# Log-scaling of the expression profile
# In this example, log-scalling is unnecessary since the expression values is already log-scalled.
# eobj <- logScale(eobj)
```

### Gene filtering
The low expressed and low variable genes can be filtered out by the following command.
As default setting, genes with expression level of higher than 1 in at least two cells 
and whose standard deviation of expression levels through all cells more than 0.05 can pass the filitering.

```{r}
# Filter out genes with low expresssion and low variance
eobj <- filterGenes(eobj)
```

The parameters can be changed by specifying the arguments cell, expressed, and sd, i.e., the default setting is `ncell = 2`, `expressed = 1.0`, and `sd = 0.05`.

```{r, eval = FALSE}
# Filter out genes with low expresssion and low variance
eobj <- filterGenes(eobj, ncell = 2, expressed = 1.0, sd = 0.05)
```

## GraphSOM clustering

Before starting GraphSOM clustering, the parameters for GraphSOM clustering should be initialized.

```{r, eval = FALSE}
eobj <- initGraphSOM(eobj)
```

In this case, all cell samples and genes are used for the clustering, 
so that it will take a long time to 
execute when the input gene expression profile is quite large.

Therefore, if downsampling is required, `graphSOM` can be executed with subsets of cell samples 
selected uniformly random from each domain, and repeats the clustering with different sets.
The `nsamples` indicates the number of samples extracted from each domain, i.e., 
`nsamples = 10` under a dataset with 4 domains means that 40 cell samples will be selected.
If the total number of samples of a certain domain is less than the value specified `nsamples`, 
all samples of the domain are selected. 
The `rept` is the number of repeats for GraphSOM clustering with different sample sets.

In addition, the `coef` is the coefficient of ARI value for score function. 
The GraphSOM results are evaluated by prediction accuracy, ARI, and a score function (= accuracy + `coef` * ARI). 
The default is `coef = 1.0`.

```{r}
eobj <- initGraphSOM(eobj, nsamples = 10, coef = 0.5, rept = 3)
```

If the sample set after downsampling needs to be fixed, set a value to the parameter `seed`.

__Note__

Even if the same random seed is given, the selected samples may differ depending on the version of R.

```{r, eval = FALSE}
eobj <- initGraphSOM(eobj, nsamples = 10, coef = 0.5, rept = 3, seed = 0)
```

From the version 0.2.8, GraphSOM clustering introduces the cluster swap method by default.
If the cluseter swap method is not needed, set `FALSE` to the option `swap` of `initGraphSOM` function.

```{r, eval = FALSE}
eobj <- initGraphSOM(eobj, nsamples = 10, coef = 0.5, rept = 3, swap = FALSE, seed = 0)
```

After initializing GraphSOM setting, GraphSOM can be executed.
The most simple way to execute GraphSOM clustering undere the parameter setting given by `initGraphSOM` is as follow.

```{r, eval = FALSE}
eobj <- graphSOM(eobj)
```

As another option,
`graphSOM` can be executed with a specific gene set by setting it
to the parameter `gset` as a `vector`.

```{r}
eobj <- graphSOM(eobj, gset = c("Actn2", "Hand2", "Vegfb", "Wnt5a"))
```

In addition to these, `graphSOM` has several parameters, so please refer to 
the manual for their details.
  
The `graphSOM` clustering results can be shown by the following.

```{r}
eobj@summary
```

The results are mean values and mean variance of the score, the prediction accuracy, and ARI for 
the repeats specified in `graphSOM` function.
The resuls of each repeat can also be shown.

```{r}
eobj@score
```

The convergence curve can be shown.
`rept` indicates the repeat numbers to be plotted.

```{r}
plotConvCurve(eobj, rept = 1:2)
```

The multiple results are plotted at the same time by the following example code.

```{r, eval = FALSE}
par(mfrow = c(2,2))
plotConvCurve(eobj)
dev.off()
```


## Feature gene selection based on random forest

`espresspo` provides a function for feature gene selection `selectFeatures`.
This function is a rapper function of `Boruta` function of `Boruta` package, which is a 
feature gene selection method based on random forest.
The usage of this function is very simple.

```{r}
fgenes <- selectFeatures(eobj, maxRuns = 100)

fgenes
```

Please note that the result of `Borta` depends on random seed. 
Thus, if the results need to be fixed, set a value to the parameter `seed`.

```{r, eval = FALSE}
fgenes <- selectFeatures(eobj, maxRuns = 100, seed = 0)
```

`Boruta` classifies genes into the three categories, "Confirmed", "Tentative", and "Rejected", according to their importance.
This function returns a vector of "NOT Rejected" genes as features by default.
If only "Confirmed" genes are required, set `"c"` to the parameter `decision`.

```{r, eval = FALSE}
fgenes <- selectFeatures(eobj, maxRuns = 100, decision = "c", seed = 0)
```

In order to resolve genes left as "Tentative", `maxRuns` may be increased,
where the parameter `maxRuns` is the maximum number of importance source runs (refer the manual of `Boruta` pacakage).
Empirically, it is good to determine the parameters so that around 100 genes are selected.


## Usage of Gene Ontology (GO) information (optional)

In order to execute `graphSOM` with functional gene sets already defined,
`espresso` provides us with gene sets in GO database.

```{r}
# Mouse gene sets (Ensembl release version 101)
data(mm_symbol_v101)

# Human gene sets (Ensembl release version 101)
data(hs_symbol_v101)
```

If another version, another species, or another gene idenfier are required,
the following command enable a user to create another gene set via R `biomaRt` package.
The parameters to be set to `species` are `gid` according to `biomaRt`.
Note that if the latest version is required, please do not specify `version` in the function.

```{r, eval = FALSE}
# Get GO information
hs_symbol_v98 <- getGO(species = 'hsapiens', gid = 'hgnc_symbol', version = '98')

# Save 'hs_symbol_v98' as an R data file.
save(hs_symbol_v98, file = "hs_symbol_v98")

# Load 'hs_symbol_v98'
load(hs_symbol_v98)
```

The GO information are stored as a list, and each element of list has two vectors, `term` and `genes`.
```{r}
mm_symbol_v101[["GO:0003209"]][["term"]]

mm_symbol_v101[["GO:0003209"]][["genes"]]
```

Thus, `graphSOM` execution using GO genes can be done by

```{r, eval = FALSE}
eobj <- graphSOM(eobj, gset = mm_symbol_v101[["GO:0003209"]][["genes"]])
```


## Gene set optimization by replica exchange Markov chain Monte Carlo method (RX-MCMC).

`espresso` optimizes gene sets by replica exchange Markov chain Monte Carlo method (RX-MCMC).
The parameters `itr`, `n_ex`, and `n_repl` are the number of iterations of MCMC until each replica exchange, 
the number of times of exchanges, and the number of replicas, respectively.
Thus, the total number of MCMC steps is `itr * n_ex`.
If the user's machine has multi-core processors, the MCMC computations of each replica are parallelized.

```{r, message = FALSE}
eobj <- initGraphSOM(eobj, nsamples = 10, rept = 1, coef = 0.5)
eobj <- rxmcmc(eobj, gset = fgenes, itr = 2, n_ex = 5, n_repl = 4)
```

Although the number of cores is automatically detected, it can be specified by `n_cl`.
In addition, as the default setting, MCMC optimizations are started with 3 genes randomly selected from 
the gene set specified by `gset`. However it can be also modified by `n_ig`.
Note that the length of `fgenes` must be larger than `n_ig`.

```{r, eval = FALSE}
eobj <- rxmcmc(eobj, gset = fgenes, itr = 2, n_ex = 5, n_repl = 4, n_cl = 4, n_ig = 3)
```

The random seed can be fixed by the `seed` option in the `rxmcmc` function.

```{r, eval = FALSE}
eobj <- rxmcmc(eobj, gset = fgenes, itr = 2, n_ex = 5, n_repl = 4, n_cl = 4, n_ig = 3, seed = 0)
```

The results of RX-MCMC are stored in `espresso` objects and they can be accessed by `@mcmc`.

* `eobj@mcmc[["sampling"]]`: History of sampling
* `eobj@mcmc[["max"]]`: History of the samples with the best score
* `eobj@mcmc[["exchange"]]`: History of replica exchange
* `eobj@mcmc[["final_genes"]]`: The final genes for each replicas
* `eobj@mcmc[["best_repl"]]`: Information of the best replicas
* `eobj@mcmc[["best_genes"]]`: The best genes

```{r}
eobj@mcmc[["sampling"]][["repl.1"]]
eobj@mcmc[["max"]][["repl.1"]]
eobj@mcmc[["exchange"]]
eobj@mcmc[["final_genes"]]
eobj@mcmc[["best_repl"]]
eobj@mcmc[["best_genes"]]
```

The results of RX-MCMC can be also obtained as text files as follows, where
`dir` is a path to an output directory.

```{r, eval = FALSE}
writeMCMC(eobj, dir = "output")
```

The histories of RX-MCMC optimization and replica exchanges can be plotted by 
`plotMCMC` function.

```{r, fig.width = 8, fig.height = 8, out.width = "45%"}
plotMCMC(eobj)
```


## Plot distance maps

In order to visualize the distance between domains and between cell samples before/after clustering for all replications,
`espresso` provides `plotDistMap`. The usage is quite simple.
```{r, fig.width = 8, fig.height = 8, out.width = "45%"}
# size_d: The font and cell sizes for distance map of domains (default: NULL).
# size_s: The font and cell sizes for distance map of cell samples (default: 5).
plotDistMap(eobj, size_s = 5)
```

## Compute and plot UMAP
`espresso` provides a function for dimension reduction method named 
Uniform Manifold Approximation and Projection (UMAP) to show the distribution of the cell samples 
in 2D or 3D space (the default space is 2D).
To compute and plot UMAP, use `runUMAP` and `plotUMAP` functions, respectively.
The UMAP result is stored `@umap`.

```{r}
eobj <- runUMAP(eobj)
head(eobj@umap)
plotUMAP(eobj, file = 'umap_2D.png')
```


```{r, echo = FALSE, fig.cap= "UMAP", out.width = '50%'}
knitr::include_graphics("umap_2D.png")
```

This function imports `uwot` packages, thus all parameters for UMAP computation can be
given according to the original package. 
When using custom settings for UMAP, give the UMAP parameters `umap_param` as a list to `runUMAP` by the following way.
For the details of the parameters, refer to `uwot::umap` function.
The feature genes can be given by `gset` parameter while 
UMAP is performed with genes stored in `@gset` if `gset = NULL`.

```{r}
eobj <- runUMAP(eobj, gset = eobj@mcmc[["best_genes"]][[1]],
                umap_param = list("n_neighbors" = 15, "n_components" = 3, "n_epochs" = 1000))
head(eobj@umap)
# size: the size for plotted points.
# magnify: Multiplicative factor to apply to size of window when producing legend (default: 1).
plotUMAP(eobj, size = 1.5, magnify = 1, file = "umap_3D.png") 
```


```{r, echo=FALSE, fig.cap= "UMAP", out.width = '50%'}
knitr::include_graphics("umap_3D.png")
```

Although the `plotUMAP` imports `rgl` package,
`scatterplot3d` package can be used instead of `rgl` by `rgl = FALSE` (default: `TRUE`) when `rgl` is not available.

```{r}
plotUMAP(eobj, file = "umap_3D_scatterplot.png", rgl = FALSE)
```


```{r, echo=FALSE, fig.cap= "UMAP", out.width = '50%'}
knitr::include_graphics("umap_3D_scatterplot.png")
```

The export format is automatically detected from its extension (Supported: png, pdf, eps)

```{r, eval = FALSE}
plotUMAP(eobj, file = 'umap.pdf')
```

The RGL window can be closed after plotting by `rglclose = TRUE`.
```{r, eval = FALSE}
plotUMAP(eobj, file = 'umap.pdf', rglclose = TRUE)
```

The file saving can be suppress by `save = FALSE`.
This is useful when you want to use `png()`, `pdf()`, and `postscript()` 
functions directly in order to specify their parameters (e.g., `width`, `height`, and so on) manually.

```{r, eval = FALSE}
pdf(file = 'umap.pdf', width = 6, height = 6)
plotUMAP(eobj, save = FALSE)
dev.off()
```

__Note__

When the exported format is 'pdf' or 'eps', and `rgl = TRUE`, 
the legend information is not printed due to the design of `rgl` package.


### Other options of UMAP plotting

Plotting colors can be changed by any colors according to the domains.

```{r}
domain_colors <- list(AHF = "orange",
                      Atrial = "pink",
                      LV = "green",
                      OFT = "lightblue",
                      pSHF = "purple",
                      RV = "blue",
                      SV = "plum"
                      )
plotUMAP(eobj, domcol = domain_colors, file = "umap_3D_color1.png", size = 1.5)
```

```{r, echo=FALSE, fig.cap= "UMAP", out.width = '50%'}
knitr::include_graphics("umap_3D_color1.png")
```

Color coding in groups different from the domains is possible with the `color_by_group` and `grpcol` options.
The `color_by_group` must be a `data.frame` given by the followin format.

|         |          |
|:--------|:--------:|
| sample  | group    |
| Cell 1  | Group 1  |
| Cell 2  | Group 2  |
| Cell 3  | Group 1  |
| Cell 4  | Group 4  |
| ...     | ...      |

The color of each group can be specified by `grpcol` of the same format as `domcol`.
The following is an example.

```{r}
path_group <- system.file("extdata", "group_soysa19_e825.txt", package="espresso")
group <- read.table(path_group, header = T, as.is = TRUE)
head(group)
group_colors <- list(FHF = "orange", SHF = "blue")
plotUMAP(eobj, color_by_group = group, grpcol = group_colors, size = 1.5, file = "umap_3D_color2.png")
```

```{r, echo=FALSE, fig.cap= "UMAP", out.width = '50%'}
knitr::include_graphics("umap_3D_color2.png")
```

In addition, the coloring of each sample can also be based on the expression levels of a gene 
rather than the domains by specifying a gene name to the argument `color_by_gene`.
In such case, the `domcol` is ignored. 

```{r}
plotUMAP(eobj, color_by_gene = "Actn2", file = "umap_3D_color3.png", size = 1.5)
```

```{r, echo=FALSE, fig.cap= "UMAP", out.width = '50%'}
knitr::include_graphics("umap_3D_color3.png")
```


If `movie = TRUE`, a movie of the resulting UMAP is generated.
This option is valid when `rgl = TRUE`.


```{r, eval = FALSE}
plotUMAP(eobj, movie = TRUE)
```

The above script uses all cell samples for UMAP plotting.
If you want to plot UMAP with downsampled sets, the following script can work.

```{r, eval = FALSE}
eobj.tmp <- eobj
samples <- eobj.tmp@ssets[["set.1"]]
eobj.tmp@exprs <- eobj.tmp@exprs[match(samples, rownames(eobj.tmp@exprs)), , drop = FALSE]
eobj.tmp <- runUMAP(eobj.tmp, gset = eobj.tmp@mcmc[["best_genes"]][[1]], 
                    umap_param = list("n_neighbors" = 5, "n_components" = 3, "n_epochs" = 1000))
plotUMAP(eobj.tmp, movie = TRUE, domcol = domain_colors)
```

UMAP is even more effective for overviewing distribution of cell samples when the number of cell samples is large.
The following figure is UMAP using GO\:0003209 for 3,331 cell samples obtained from 
[GSE126128_E775E825_WTKO_10X.csv.gz](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE126128).

```{r, echo=FALSE, fig.cap= "UMAP", out.width = '50%'}
knitr::include_graphics("umap.all.png")
```

## Appendix
The gene description can be obtained via `biomaRt` package as followings:
```{r, eval=FALSE}
library(biomaRt)
fgenes <- c("Actn2", "Hand2", "Vegfb", "Wnt5a")
ds <- useEnsembl(biomart = 'ensembl', dataset = 'mmusculus_gene_ensembl')
ann <- getBM(attributes = c("mgi_symbol", "description"), 
             mart = ds, filters = "mgi_symbol", values = fgenes)
```

__Note__

If the version of R is 3.6 or later, the above script may not work depending on the version of biomaRt (e.g., >= 2.42.0).
In that case, add the option `useCache = False` to the `getBM` function.

```{r, eval=FALSE}
ann <- getBM(attributes = c("mgi_symbol", "description"), 
             mart = ds, filters = "mgi_symbol", values = fgenes, useCache = FALSE)
```

